     # common-interview-question-last
      ////
	 ES6

	ES6的了解

	es6是一个新的标准，它包含了许多新的语言特性和库，是JS最实质性的一次升级。比如’箭头函数’、
	’字符串模板’、’generators(生成器)’、’async/await’、’解构赋值’、
	’class’等等，还有就是引入module模块的概念。

	箭头函数可以让this指向固定化，这种特性很有利于封装回调函数
	（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
	（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
	（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
	（4）不可以使用yield命令，因此箭头函数不能用作Generator函数。

	async/await是写异步代码的新方式，以前的方法有回调函数和Promise。
	async/await是基于Promise实现的，它不能用于普通的回调函数。
	async/await与Promise一样，是非阻塞的。
	async/await使得异步代码看起来像同步代码，这正是它的魔力所在。

	说说你对Promise的理解

	Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件监听——更合理和更强大。

	所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
	从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
	Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。

	Promise对象有以下两个特点:

	对象的状态不受外界影响，Promise对象代表一个异步操作，
	有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）
	一旦状态改变，就不会再变，任何时候都可以得到这个结果。
	说说你对AMD和Commonjs的理解

	CommonJS是服务器端模块的规范，Node.js采用了这个规范。
	CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。
	AMD规范则是非同步加载模块，允许指定回调函数。

	AMD推荐的风格通过返回一个对象做为模块对象，
	CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。

	Gulp、Webpack比较

	Gulp
	1、Gulp就是为了规范前端开发流程，实现前后端分离、
	模块化开发、版本控制、文件合并与压缩、mock数据等功能的一个前端自动化构建工具。
	2、Gulp就像是一个产品的流水线，整个产品从无到有，
	都要受流水线的控制，在流水线上我们可以对产品进行管理。
	3、Gulp是通过task对整个开发过程进行构建。

	Webpack
	1、当下最热门的前端资源模块化管理和打包工具
	2、可以很好的管理模块以及各个模块之间的依赖
	3、对js、css、图片等资源文件都支持打包
	4、有独立的配置文件webpack.config.js
	5、可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间
	6、可以生成优化且合并后的静态资源

	两大特色：1、代码可以自动完成编译。2、loader 可以处理各种类型的静态文件，
	并且支持串联操作

	CSS

	display:none和visibility:hidden的区别？

	display:none 隐藏对应的元素，在文档布局中不再给它分配空间，
	它各边的元素会合拢，就当他从来不存在。

	visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。

	position:absolute和float属性的异同

	A：共同点：
	对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。

	B：不同点：
	float仍会占据位置，position会覆盖文档流中的其他元素。

	box-sizing属性

	content-box：让元素维持W3C的标准盒模型。
	元素的宽度/高度由border + padding + content的宽度/高度决定，
	设置width/height属性指的是content部分的宽/高，一旦修改了元素的边框或内距，
	就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。

	border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。
	设置width/height属性指的是border + padding + content

	position的值

	static 默认值。没有定位，元素出现在正常的流中
	relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。
	absolute 生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。
	fixed （老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位。
	CSS3新特性

	CSS3实现圆角（border-radius），阴影（box-shadow），
	对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
	transform:rotate(9deg) 
	scale(0.85,0.90) 
	translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜
	增加了更多的CSS选择器 多背景 rgba
	在CSS3中唯一引入的伪元素是::selection.
	媒体查询，多栏布局
	border-image

	CSS sprites

	CSS Sprites 其实就是把网页中一些背景图片整合到一张图片文件中，
	再利用CSS的“background-image”，“background- repeat”，
	“background-position”的组合进行背景定位，
	background-position可以用数字能精确的定位出背景图片的位置。这样可以减少很多图片请求的开销，
	因为请求耗时比较长；请求虽然可以并发，但是也有限制，一般浏览器都是6个。
	对于未来而言，就不需要这样做了，因为有了http2。
	解释下浮动和它的工作原理？清除浮动的技巧

	浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。
	1.使用空标签清除浮动。
	这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。
	2.使用overflow。
	设置overflow为hidden或者auto，
	给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。
	3.使用after伪对象清除浮动。
	该方法只适用于非IE浏览器。
	该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；



	浮动元素引起的问题

	1、父元素的高度无法被撑开，影响与父元素同级的元素
	2、与浮动元素同级的非浮动元素（内联元素）会跟随其后
	3、若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构

	HTML

	说说你对语义化的理解

	1、去掉或者丢失样式的时候能够让页面呈现出清晰的结构
	2、有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
	3、方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
	4、便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。

	Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

	1、<!DOCTYPE> 告知浏览器的解析器用什么文档标准解析这个文档。
	2、严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。
	3、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
	4、<!DOCTYPE> 不存在或格式不正确会导致文档以混杂模式呈现。

	你知道多少种Doctype文档类型？

	该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。
	HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。
	XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。
	Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，
	而 Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。

	HTML与XHTML——二者有什么区别

	1、所有的标记都必须要有一个相应的结束标记
	2、所有标签的元素和属性的名字都必须使用小写
	3、所有的XML标记都必须合理嵌套
	4、所有的属性必须用引号””括起来
	5、把所有<和&特殊符号用编码表示
	6、给所有属性赋一个值
	7、不要在注释内容中使“–”
	8、图片必须有说明文字

	html5有哪些新特性

	语义化更好的内容标签（header,nav,footer,aside,article,section）
	音频、视频API(audio,video)
	画布(Canvas) API
	地理(Geolocation) API
	拖拽释放(Drag and drop) API
	本地离线存储
	表单控件，calendar、date、time、email、url、search

	计算机网络

	HTTP请求四部分

	1、HTTP请求的方法或动作，比如是get还是post请求；
	2、正在请求的URL（请求的地址）；
	3、请求头，包含一些客户端环境信息、身份验证信息等；
	4、请求体（请求正文），可以包含客户提交的查询字符串信息、表单信息等。

	请求头字段：

	Accept:text/html,image/*(告诉服务器，浏览器可以接受文本，网页图片)
	Accept-Charaset:ISO-8859-1 [接受字符编码：iso-8859-1]
	Accept-Encoding:gzip,compress[可以接受 gzip,compress压缩后数据]
	Accept-Language:zh-cn[浏览器支持的语言]
	Host:localhost:8080[浏览器要找的主机]
	If-Modified-Since:Tue, 09 May 2017 01:34:02 GMT[告诉服务器我这缓存中有这个文件,该文件的时间是…]
	User-Agent:Nozilla/4.0(Com…)[告诉服务器我的浏览器内核，客户端环境信]
	Cookie：[身份验证信息]
	Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接]
	HTTP响应三部分

	1、一个数字和文字组成的状态码，用来显示请求是成功还是失败；
	2、响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等；
	3、响应体（响应正文）。

	响应头字段：

	Cache-Control:[告诉浏览器如何缓存页面(因为浏览器的兼容性最好设置两个)]
	Connection:close/Keep-Alive [保持链接，发完数据后，我不关闭链接]
	Content-Type:text/html;charset=gb2312[内容格式和编码]
	Last-Modified:Tue,11 Juj,2017 18 18:29:20[告诉浏览器该资源上次更新时间是多少]
	ETag:”540-54f0d59b8b680”
	Expires:Fri, 26 May 2017 13:28:33 GMT [失效日期]
	server:apache tomcat nginx [哪种服务器]
	说说TCP传输的三次握手

	第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。
	此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。

	第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。
	此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。
	服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。

	第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。
	客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。

	为什么要三次握手：
	为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源
	TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，
	又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！

	四次挥手

	1、主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段；
	2、服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段；
	3、服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接；
	4、主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接；

	TCP和UDP的区别

	TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，
	在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来

	UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。
	它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
	UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。

	HTTP和HTTPS

	1、HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS
	2、默认HTTP的端口号为80，HTTPS的端口号为443

	HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，
	但是加密解密的运算处理已经可以通过特有的硬件来加速处理。

	什么是Etag？

	把Last-Modified和ETag请求的http报头一起使用，可利用客户端（例如浏览器）的缓存。
	ETag用于标识资源的状态，当资源发生变更时，如果其头信息中一个或者多个发生变化，
	或者消息实体发生变化，那么ETag也随之发生变化。浏览器下载组件的时候，
	会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，
	假如已经过期，那么浏览器将发送一个条件GET请求到服务器，
	服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。

	Expires和Cache-Control

	Expires 用来控制缓存的失效日期
	Cache-Control 用来控制网页的缓存 常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。

	关于Http 2.0 你知道多少？

	HTTP/2引入了“服务端推（server push）”的概念，
	它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。
	HTTP/2提供更多的加密支持
	HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。
	它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。

	一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

	1、浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求（TCP三次握手）；
	2、服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；
	3、浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
	4、载入解析到的资源文件，渲染页面，完成。

	浏览器的渲染过程

	1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。
	浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：
	当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
	2、CSS文件下载完成，开始构建CSSOM
	3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。
	4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。
	下一步操作就是计算出每个节点在屏幕中的位置。
	5、最后一步，按照算出来的规则，把内容渲染到屏幕上。

	以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，
	比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，
	除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。

	display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，
	所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。

	一个完整的URL包括以下几部分

	1、协议部分
	2、域名部分
	3、端口部分
	4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止
	5、文件名部分：从域名后的最后一个“/”开始到“？”为止
	6、参数部分：从“？”开始到“#”为止之间的部分
	7、锚部分：从“#”开始到最后

	GET和POST的区别

	GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在1024字节，Get是通过地址栏来传值。

	POST：一般用于修改服务器上的资源，对所发送的信息没有限制。
	（常用于发送表单数据，新建、修改等），Post是通过提交表单来传值。

	常见HTTP状态码

	1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。
	2xx（成功）表示成功处理了请求的状态码。
	200（成功）：服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
	3xx（重定向）要完成请求，需要进一步操作。
	301（永久移动）：请求的网页已永久移动到新位置。
	302（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。
	304（未修改）：自从上次请求后，请求的网页未修改过。
	4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。
	400（错误请求）：服务器不理解请求的语法。
	404（未找到）：服务器找不到请求的网页。
	5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。
	500（服务器内部错误）：服务器遇到错误，无法完成请求。
	503（服务不可用）：服务器目前无法使用（由于超载或停机维护）。

	说说网络分层里七层模型是哪七层

	应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）

	传输层（TCP和UDP）

	网络层（IP）

	物理和数据链路层（以太网）

	讲讲304缓存的原理

	服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。
	本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。

	304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件

	http keep-alive与tcp keep-alive

	http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，
	提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。

	常见web安全及防护原理

	sql注入原理
	就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
	XSS
	指的是攻击者往Web页面里插入恶意html标签或者javascript代码。
	比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，
	窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，
	当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。
	CSRF
	CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。
	要完成一次CSRF攻击，受害者必须依次完成两个步骤：
	1、登录受信任网站A，并在本地生成Cookie。2、在不登出A的情况下，访问危险网站B。
	算法

	数组去重

	建一个空对象和空数组，循环遍历需要去重的数组，判断对象有没有此属性，
	没有的话就给对象添加此属性，并向空数组中push这个值。

	冒泡排序

	相邻两个对比，最后把最大的排到了最后，重复此过程。


	选择排序

	寻找最小的数，保存索引，然后与第一层循环其下标对于的值进行交换


	快速排序

	选取一个记录作为中间轴，然后将比‘这个记录值’小的移到‘记录值’之前，大的移到之后，然后递归


	其它

	对前端界面工程师这个职位是怎么样理解的

	前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好
	1、实现界面交互
	2、提升用户体验

	谈谈你对重构的理解

	在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。
	也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。

	减少代码间的耦合
	让代码保持弹性
	严格按规范编写代码
	设计可扩展的API
	代替旧有的框架、语言(如VB)
	增强用户体验
	通常来说对于速度的优化也包含在重构中

	你遇到过比较难的技术问题是？你是如何解决的？

	平时是如何学习前端开发的？

	平时如何管理你的项目？

	先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等；

	编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；

	标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；

	页面进行标注（例如 页面 模块 开始和结束）；

	CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）；

	JS 分文件夹存放 命名以该JS功能为准的英文翻译。

	图片采用整合的 images.png png8 格式文件使用尽量整合在一起使用方便将来的管理
